<!DOCTYPE html>
<html>
  <head>
    <title>Portal Scraper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <style>
      .stage {
        padding: 10px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 5px;
        transition: all 0.3s;
      }
      .stage.active {
        background: #fff3cd;
        border-color: #ffeeba;
      }
      .stage.completed {
        background: #d4edda;
        border-color: #c3e6cb;
      }
      .stage.error {
        background: #f8d7da;
        border-color: #f5c6cb;
      }
      .event-log {
        height: 200px;
        overflow-y: auto;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 5px;
        margin-top: 15px;
      }
      .event-item {
        padding: 5px;
        margin: 5px 0;
        border-left: 3px solid #007bff;
      }
      .event-item.error {
        border-left-color: #dc3545;
      }
      .last-run-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1rem;
      }
      .last-run-info {
        min-width: 250px;
      }
      .error-details {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        border-radius: 4px;
        padding: 1rem;
        margin-top: 1rem;
        word-break: break-word;
      }
      .toast-container {
        z-index: 1050;
      }
      @media (max-width: 768px) {
        .last-run-container {
          grid-template-columns: 1fr;
        }
      }
      .member-form {
        display: none;
        margin-top: 1rem;
      }

      .member-form.active {
        display: block;
      }

      .workspace-select {
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div class="container my-4">
      <!-- Navigation -->
      <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4">
        <div class="container-fluid">
          <a class="navbar-brand" href="/"> Website Monitor </a>
          <a class="btn btn-outline-primary" href="/">Back to Dashboard</a>
        </div>
      </nav>

      <!-- Last Run Status section -->
      <div class="card mb-4">
        <div class="card-header bg-primary text-white">
          <h5 class="card-title mb-0">Last Run Status</h5>
        </div>
        <div class="card-body">
          <div id="lastRunStatus">
            <div class="alert alert-info">
              <div class="last-run-container">
                <div class="last-run-info">
                  <p>
                    <strong>Last Run:</strong>
                    <span id="lastRunTime">Never</span>
                  </p>
                  <p>
                    <strong>Status:</strong>
                    <span id="lastRunStatus">No runs yet</span>
                  </p>
                  <p>
                    <strong>Username:</strong>
                    <span id="lastUsername">N/A</span>
                  </p>
                  <p>
                    <strong>Portal:</strong> <span id="lastPortal">N/A</span>
                  </p>
                  <p>
                    <strong>Auto Run:</strong>
                    <span id="autoRunStatus">Disabled</span>
                  </p>
                  <p>
                    <strong>Next Run:</strong>
                    <span id="nextRunDisplay" class="text-muted"
                      >Not scheduled</span
                    >
                  </p>
                </div>
                <div
                  id="errorDetails"
                  class="error-details"
                  style="display: none"
                >
                  <h6 class="text-danger">Error Details</h6>
                  <div id="errorMessage"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <h1 class="mb-4">Portal Scraper</h1>

      <div class="row">
        <!-- Scraper Form -->
        <div class="col-md-4">
          <div class="card">
            <div class="card-header bg-primary text-white">
              <h5 class="card-title mb-0">Start New Scrape</h5>
            </div>
            <div class="card-body">
              <form
                id="scraperForm"
                class="needs-validation"
                novalidate
                onsubmit="startScraper(event)"
              >
                <div class="mb-3">
                  <label for="username" class="form-label">Email</label>
                  <input
                    type="email"
                    class="form-control"
                    id="username"
                    name="username"
                    required
                  />
                </div>
                <div class="mb-3">
                  <label for="password" class="form-label">Password</label>
                  <input
                    type="password"
                    class="form-control"
                    id="password"
                    name="password"
                    required
                  />
                </div>
                <div class="mb-3">
                  <label for="portal" class="form-label">Portal</label>
                  <input
                    type="text"
                    class="form-control"
                    id="portal"
                    name="portal"
                    value="fcm"
                  />
                </div>
                <button type="submit" class="btn btn-primary w-100">
                  Start Scraping
                </button>
              </form>
            </div>
          </div>

          <!-- Scheduler Settings -->
          <div class="card mt-4">
            <div class="card-header bg-primary text-white">
              <h5 class="card-title mb-0">Scheduler Settings</h5>
            </div>
            <div class="card-body">
              <form id="schedulerForm" onsubmit="saveSchedulerSettings(event)">
                <div class="mb-3">
                  <div class="form-check form-switch">
                    <input
                      class="form-check-input"
                      type="checkbox"
                      id="autoRunEnabled"
                    />
                    <label class="form-check-label" for="autoRunEnabled"
                      >Enable Auto Run</label
                    >
                  </div>
                </div>
                <div class="mb-3">
                  <label for="runInterval" class="form-label"
                    >Run Interval (minutes)</label
                  >
                  <input
                    type="number"
                    class="form-control"
                    id="runInterval"
                    value="60"
                    min="1"
                  />
                  <div class="form-text">Minimum interval: 1 minute</div>
                </div>
                <div class="mb-3">
                  <label class="form-label">Next Scheduled Run:</label>
                  <p id="nextRunTime" class="mb-0 text-primary">
                    Not scheduled
                  </p>
                </div>
                <button type="submit" class="btn btn-primary w-100">
                  Save Settings
                </button>
              </form>
            </div>
          </div>
        </div>

        <!-- Status Display -->
        <div class="col-md-8">
          <div class="card">
            <div class="card-header bg-primary text-white">
              <h5 class="card-title mb-0">Scraper Status</h5>
            </div>
            <div class="card-body">
              <div id="scrapperStatus">
                <p class="text-muted">Waiting to start...</p>
              </div>

              <!-- Progress Stages -->
              <div class="progress-stages mt-4">
                <div class="stage" id="initialization-stage">
                  <h6 class="stage-label">Browser Setup</h6>
                  <p>Not started</p>
                  <small></small>
                </div>
                <div class="stage" id="authentication-stage">
                  <h6 class="stage-label">Portal Login</h6>
                  <p>Not started</p>
                  <small></small>
                </div>
                <div class="stage" id="member_management-stage">
                  <h6 class="stage-label">Member Management</h6>
                  <p>Not started</p>
                  <small></small>
                </div>
                <div class="stage" id="workspace_navigation-stage">
                  <h6 class="stage-label">Workspace Navigation</h6>
                  <p>Not started</p>
                  <small></small>
                </div>
              </div>

              <!-- Event Log -->
              <div class="event-log mt-4">
                <h6 class="text-primary">Event Log</h6>
                <div id="eventLog"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Toast Container -->
      <div
        id="toastContainer"
        class="toast-container position-fixed top-0 end-0 p-3"
      ></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const socket = io();

      // Define stage configuration at the top level
      const stageConfig = {
        initialization: {
          steps: ["browser_setup", "session_creation"],
          next: "authentication",
          required: true,
        },
        authentication: {
          steps: [
            "load_login",
            "enter_email",
            "enter_password",
            "verify_login",
          ],
          next: "member_management",
          required: true,
        },
        member_management: {
          steps: ["navigate_members", "add_member", "assign_workspace"],
          next: "workspace_navigation",
          required: true,
          blocking: true,
        },
        workspace_navigation: {
          steps: ["navigate_flights", "select_workspace"],
          next: null,
          required: true,
          requires: ["member_management"],
        }
      };

      // API endpoints definition
      const API_ENDPOINTS = {
        START_SCRAPING: "/fcm/start_scraping",
        LAST_STATE: "/fcm/last_state",
        SETTINGS: "/fcm/settings",
        UPDATE_SETTINGS: "/fcm/settings", // Not UPDATE_SETTINGS to match route
      };

      // Socket Event Handlers
      socket.on("connect", function () {
        console.log("Socket connected");
        showToast("Connected to server", "success");
        // Refresh states on reconnection
        Promise.all([loadInitialState(), loadSchedulerSettings()]);
      });

      socket.on("portal_scraper_status", function (data) {
        console.log("Status update:", data);

        // Update status message
        updateStatus(data.message, data.status === "error" ? "error" : "info");

        // Update stage with timing
        if (data.stage && data.status) {
          updateStageStatus(data.stage, data.status, data.message, data.timing);
          // Add to event log with timing
          addEventLog({
            type: data.status === "error" ? "error" : "info",
            message: `${data.stage.toUpperCase()}: ${data.message}`,
            elapsed: data.timing,
          });
        }
      });

      socket.on("portal_scraper_progress", function (data) {
        console.log("Progress update:", data);
        if (!data) return;

        if (data.stage && data.step) {
          const stageElement = document.getElementById(`${data.stage}-stage`);
          if (stageElement) {
            // Update content
            const messageEl = stageElement.querySelector("p");
            const timingEl = stageElement.querySelector("small");

            messageEl.textContent = `${data.step}: ${
              data.message || "In progress..."
            }`;
            if (data.data?.timing) {
              timingEl.textContent = `${data.data.timing}s`;
            }

            // Safely handle color and status
            stageElement.style.backgroundColor = data.color || "";
            stageElement.className = `stage ${data.status || ""}`;
          }
        }
      });

      socket.on("portal_scraper_completed", async function(data) {
        console.log("Scraping completed:", data);
        
        // Safely parse any remaining timestamp strings
        const parseTimestamps = (obj) => {
            if (!obj) return obj;
            
            if (typeof obj === 'string' && obj.match(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/)) {
                return new Date(obj);
            }
            
            if (Array.isArray(obj)) {
                return obj.map(parseTimestamps);
            }
            
            if (typeof obj === 'object') {
                const newObj = {};
                for (const [key, value] of Object.entries(obj)) {
                    newObj[key] = parseTimestamps(value);
                }
                return newObj;
            }
            
            return obj;
        };
        
        // Parse any timestamp strings in the data
        data = parseTimestamps(data);
        
        if (data.success) {
            showToast("Operation completed successfully", "success");
            updateStatus("Operation completed successfully", "success");
            updateAllStagesCompletion();
        } else {
            showToast(data.message || "Operation failed", "error");
            updateStatus(data.message || "Operation failed", "error");
        }

        // Refresh states after completion
        try {
            await Promise.all([
                loadInitialState(),
                loadSchedulerSettings()
            ]);
        } catch (error) {
            console.error("Error refreshing state after completion:", error);
        }
      });

      socket.on("portal_scraper_error", function (data) {
        console.error("Scraper error:", data);
        // Show error in UI
        showError(data.message, data.error);
        updateStatus(data.message, "error");
        // Update stage status if provided
        if (data.stage) {
          updateStageStatus(data.stage, "error", data.message);
        }
        // Add to error log
        addEventLog({
          type: "error",
          message: `ERROR: ${data.message}`,
        });
      });

      socket.on("portal_settings_updated", function (data) {
        console.log("Settings updated:", data);
        // Update scheduler UI
        updateSchedulerUI({
          auto_run: data.auto_run,
          interval: data.interval,
          next_run: data.next_run,
        });
        // Update next run display
        updateNextRunDisplay(data.next_run, data.auto_run);
        // Refresh state to show updated auto-run state
        loadInitialState();
        // Show confirmation
        showToast("Scheduler settings updated", "success");
      });

      // Add helper functions for new UI updates
      function updateStageVisual(stage, status) {
        const stageElement = document.getElementById(`${stage}-stage`);
        if (stageElement) {
          // Remove existing status classes
          stageElement.classList.remove("active", "completed", "error");
          // Add appropriate status class
          switch (status) {
            case "starting":
            case "in_progress":
              stageElement.classList.add("active");
              break;
            case "completed":
              stageElement.classList.add("completed");
              break;
            case "error":
              stageElement.classList.add("error");
              break;
          }
        }
      }

      function updateAllStagesCompletion() {
        const stages = [
          "initialization",
          "authentication",
          "member_management",
          "workspace_navigation"
        ];
        stages.forEach((stage) => {
          updateStageStatus(stage, "completed", "Completed");
        });
      }

      function updateNextRunDisplay(nextRun, autoRun) {
        const nextRunDisplay = document.getElementById("nextRunDisplay");
        const nextRunTime = document.getElementById("nextRunTime");
        const displayText = nextRun
          ? new Date(nextRun).toLocaleString()
          : "Not scheduled";
        const displayClass = autoRun ? "text-success" : "text-muted";
        if (nextRunDisplay) {
          nextRunDisplay.textContent = displayText;
          nextRunDisplay.className = displayClass;
        }
        if (nextRunTime) {
          nextRunTime.textContent = displayText;
          nextRunTime.className = displayClass;
        }
      }

      // Form Handlers
      async function startScraper(event) {
        event.preventDefault();
        const submitBtn = event.target.querySelector('button[type="submit"]');
        const form = event.target;

        try {
          submitBtn.disabled = true;
          form.classList.add("was-validated");

          if (!form.checkValidity()) {
            throw new Error("Please fill all required fields");
          }

          const formData = {
            username: document.getElementById("username").value,
            password: document.getElementById("password").value,
            portal: document.getElementById("portal").value,
            member_data: {
              name: document.getElementById("memberName").value || "mayuri",
              email:
                document.getElementById("memberEmail").value ||
                "sushu@yopmail.com",
              workspace:
                document.getElementById("memberWorkspace").value ||
                "Haldia tech",
              role: document.getElementById("memberRole").value || "User",
            },
          };

          resetUI();
          showProgressTracker();

          const response = await fetch(API_ENDPOINTS.START_SCRAPING, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(formData),
          });

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.message);
          }

          updateStatus("Scraper started successfully", "info");
        } catch (error) {
          showToast(error.message, "error");
          updateStatus(error.message, "error");
        } finally {
          submitBtn.disabled = false;
        }
      }

      async function saveSchedulerSettings(event) {
        event.preventDefault();
        const button = event.submitter;
        button.disabled = true;
        try {
          const settings = {
            auto_run: document.getElementById("autoRunEnabled").checked,
            interval: parseInt(document.getElementById("runInterval").value),
          };
          if (settings.interval < 1) {
            throw new Error("Minimum interval is 1 minute");
          }
          const response = await fetch(API_ENDPOINTS.UPDATE_SETTINGS, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(settings),
          });
          const result = await response.json();
          if (!result.success) {
            throw new Error(result.message);
          }
          updateSchedulerUI(result.settings);
          showToast("Settings updated successfully", "success");
          await loadInitialState();
        } catch (error) {
          showToast(error.message, "error");
        } finally {
          button.disabled = false;
        }
      }

      // State Loading Functions
      async function loadInitialState() {
        try {
          const response = await fetch(API_ENDPOINTS.LAST_STATE);
          const data = await response.json();

          if (!data || !data.success) {
            throw new Error(data?.message || "Failed to load state");
          }

          updateLastRunStatus(data.data || {});
          prefillForm(data.data);
        } catch (error) {
          console.error("Error loading initial state:", error);
          updateLastRunStatus({});
          showToast("Failed to load initial state", "error");
        }
      }

      async function loadSchedulerSettings() {
        try {
          const response = await fetch(API_ENDPOINTS.SETTINGS);
          const data = await response.json();
          if (!data.success) {
            throw new Error(data.message);
          }
          updateSchedulerUI(
            data.settings || { auto_run: false, interval: 60, next_run: null }
          );
        } catch (error) {
          console.error("Error loading scheduler settings:", error);
          updateSchedulerUI({ auto_run: false, interval: 60, next_run: null });
        }
      }

      // UI Update Functions
      function updateLastRunStatus(data = {}) {
        const statusDiv = document.getElementById("lastRunStatus");
        const statusClass = getStatusClass(data?.state);
        const errorMessage = data.state === "failed" ? data.message : "";
        
        statusDiv.innerHTML = `
        <div class="alert alert-${statusClass}">
          <div class="last-run-container">
            <div class="last-run-info">
              <p><strong>Last Run:</strong> ${formatTimestamp(
                data?.last_run
              )}</p>
              <p><strong>Status:</strong> ${data?.state || "Never run"}</p>
              <p><strong>Username:</strong> ${data?.username || "N/A"}</p>
              <p><strong>Portal:</strong> ${data?.portal || "N/A"}</p>
              <p>
                <strong>Auto Run:</strong> ${
                  data?.auto_run ? "Enabled" : "Disabled"
                }
              </p>
              <p><strong>Next Run:</strong> ${formatTimestamp(
                data?.next_run
              )}</p>
            </div>
            ${
              data?.state === "failed" && data?.message
                ? createErrorDetails(data)
                : ""
            }
          </div>
        </div>
        `;
      }

      function updateSchedulerUI(settings) {
        document.getElementById("autoRunEnabled").checked = settings.auto_run;
        document.getElementById("runInterval").value = settings.interval;
        document.getElementById("nextRunTime").textContent = formatTimestamp(
          settings.next_run
        );
      }

      function updateProgressDisplay(data) {
        const stageElement = document.getElementById(`${data.stage}-stage`);
        if (stageElement) {
          stageElement.querySelector(
            "p"
          ).textContent = `${data.step}: ${data.message}`;
          stageElement.className = `stage ${data.status}`;
        }
      }

      // Utility Functions
      function resetUI() {
        document.querySelectorAll(".stage").forEach((stage) => {
          stage.className = "stage";
          stage.querySelector("p").textContent = "Not started";
          stage.querySelector("small").textContent = "";
        });
        document.getElementById("eventLog").innerHTML = "";
        document.getElementById("scrapperStatus").innerHTML =
          '<p class="text-muted">Starting...</p>';
      }

      function showProgressTracker() {
        document.querySelectorAll(".stage").forEach((stage) => {
          const stageId = stage.id.replace("-stage", "");
          if (stageConfig[stageId]) {
            // All stages start disabled except initialization
            if (stageId !== "initialization") {
              stage.classList.add("disabled");
              stage.querySelector(".stage-label")?.classList.add("text-muted");
            }
            // Add required indicator
            const label = stage.querySelector(".stage-label");
            if (label && stageConfig[stageId].required) {
              label.textContent += " (Required)";
            }
          }
        });
        updateStageStatus("initialization", "starting", "Starting...");
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) return "Not scheduled";
        try {
          return new Date(timestamp).toLocaleString();
        } catch (e) {
          console.error("Invalid timestamp:", e);
          return "Invalid date";
        }
      }

      function getStatusClass(state) {
        if (!state) return "info";
        switch (state.toLowerCase()) {
          case "completed":
            return "success";
          case "failed":
            return "danger";
          case "running":
            return "warning";
          default:
            return "info";
        }
      }

      function createErrorDetails(data) {
        if (!data.message) return "";
        return `
        <div class="error-details mt-3">
          <h6 class="text-danger">Error Details</h6>
          <p class="mb-0">${data.message}</p>
        </div>
        `;
      }

      function prefillForm(data) {
        if (!data) return;
        if (data.username)
          document.getElementById("username").value = data.username;
        if (data.portal) document.getElementById("portal").value = data.portal;
      }

      function showToast(message, type = "info") {
        const toastContainer = document.getElementById("toastContainer");
        const toast = document.createElement("div");
        toast.className = `toast show bg-${
          type === "error" ? "danger" : "success"
        } text-white`;
        toast.innerHTML = `
        <div class="toast-body">
          ${message}
          <button
            type="button"
            class="btn-close btn-close-white"
            data-bs-dismiss="toast"
          ></button>
        </div>
        `;
        toastContainer.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
      }

      // Initialize on page load
      document.addEventListener("DOMContentLoaded", async function () {
        try {
          await Promise.all([loadInitialState(), loadSchedulerSettings()]);
        } catch (error) {
          console.error("Initialization error:", error);
          showToast("Failed to initialize application", "error");
        }
      });

      function updateStageStatus(stage, status, message, timing = null) {
        if (!stage) return;

        const stageElement = document.getElementById(`${stage}-stage`);
        if (!stageElement) return;

        // Safely update class and content
        stageElement.className = `stage ${status || ""}`;

        const messageElement = stageElement.querySelector("p");
        const timingElement = stageElement.querySelector("small");

        if (messageElement) {
          messageElement.textContent = message || "In progress...";
        }

        if (timingElement) {
          timingElement.textContent = timing ? `${timing}s` : "";
        }

        // Add to event log with null checks
        addEventLog({
          type: status === "error" ? "error" : "info",
          message: `${stage.toUpperCase()}: ${message || "No message"}`,
          elapsed: timing,
        });
      }

      function addEventLog(data = {}) {
        const eventLogDiv = document.getElementById("eventLog");
        if (!eventLogDiv) return;

        const eventItem = document.createElement("div");
        eventItem.className = `event-item ${data.type === "error" ? "error" : ""}`;

        const timestamp = data.timestamp || new Date().toLocaleTimeString();
        const timingStr = data.elapsed ? ` (${data.elapsed}s)` : "";
        const stageInfo = data.stage ? `[${data.stage}${data.step ? ' - ' + data.step : ''}] ` : "";

        eventItem.innerHTML = `
            <small class="text-muted">${timestamp}</small>
            <span class="ms-2">${stageInfo}${data.message}${timingStr}</span>
        `;

        eventLogDiv.insertBefore(eventItem, eventLogDiv.firstChild);
      }

      // CSV upload toggle
      document
        .getElementById("uploadCSV")
        .addEventListener("change", function (e) {
          document.getElementById("csvUpload").style.display = e.target.checked
            ? "block"
            : "none";
        });

      // File upload helper

      socket.on("portal_file_progress", function (data) {
        if (!data) return;

        const fileTypeMap = {
          invoice: "Invoice",
          report: "Report",
          csv: "CSV",
        };

        const statusColorMap = {
          starting: "text-warning",
          completed: "text-success",
          error: "text-danger",
        };

        const eventLogDiv = document.getElementById("eventLog");
        const eventItem = document.createElement("div");
        eventItem.className = `event-item ${data.status}`;

        const timestamp = new Date().toLocaleTimeString();
        const fileType = fileTypeMap[data.type] || data.type;

        eventItem.innerHTML = `
            <small class="text-muted">${timestamp}</small>
            <span class="ms-2 ${statusColorMap[data.status] || ""}">
                ${fileType}: ${data.message}
            </span>
        `;

        eventLogDiv.appendChild(eventItem);
        eventLogDiv.scrollTop = eventLogDiv.scrollHeight;

        // Update status display if needed
        const statusDiv = document.getElementById("scrapperStatus");
        if (data.status === "completed" || data.status === "error") {
          const statusMessage = `${fileType} processing ${data.status}`;
          updateStatus(statusMessage, data.status);
        }
      });

      // Member management form event handlers
      document
        .getElementById("memberForm")
        .addEventListener("submit", async function (event) {
          event.preventDefault();
          const submitBtn = event.target.querySelector('button[type="submit"]');
          submitBtn.disabled = true;

          try {
            const formData = {
              username: document.getElementById("username").value, // Use current username
              name: document.getElementById("memberName").value,
              email: document.getElementById("memberEmail").value,
              workspace: document.getElementById("memberWorkspace").value,
              role: document.getElementById("memberRole").value,
            };

            const response = await fetch("/fcm/member", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(formData),
            });

            const result = await response.json();
            if (!result.success) {
              throw new Error(result.message);
            }

            showToast("Member added successfully", "success");
            event.target.reset();
          } catch (error) {
            showToast(error.message, "error");
          } finally {
            submitBtn.disabled = false;
          }
        });

      // Add member management stage to progress display
      const stageProgress = {
        member_management: {
          element: document.getElementById("member-management-stage"),
          steps: ["navigate_members", "add_member", "assign_workspace"],
          required: true, // Now marked as required
        },
        // ...existing stages...
      };

      // Update socket event handler for member progress
      // ...existing progress handling...

      // Handle member management specific updates
      if (data.stage === "member_management") {
        const memberStatus = document.getElementById("memberStatus");
        if (memberStatus) {
          memberStatus.textContent = data.message;
          memberStatus.className = `text-${
            data.status === "completed" ? "success" : "info"
          }`;
        }
      }

      // Add member history display
      async function loadMemberHistory() {
        try {
          const response = await fetch("/fcm/member/history");
          const data = await response.json();
          if (data.success) {
            const historyContainer = document.getElementById("memberHistory");
            historyContainer.innerHTML = data.operations
              .map(
                (op) => `
                    <div class="member-history-item">
                        <p><strong>Email:</strong> ${op.member_email}</p>
                        <p><strong>Workspace:</strong> ${op.workspace}</p>
                        <p><strong>Added by:</strong> ${op.username}</p>
                        <p><strong>Date:</strong> ${new Date(
                          op.timestamp
                        ).toLocaleString()}</p>
                    </div>
                `
              )
              .join("");
          }
        } catch (error) {
          console.error("Error loading member history:", error);
        }
      }

      // Add these functions right after socket initialization

      // Handle initial page load state
      async function initializePage() {
        try {
          showLoadingState();
          const [stateResponse, settingsResponse] = await Promise.all([
            fetch(API_ENDPOINTS.LAST_STATE),
            fetch(API_ENDPOINTS.SETTINGS),
          ]);

          const stateData = await stateResponse.json();
          const settingsData = await settingsResponse.json();

          if (stateData.success) {
            updateLastRunStatus(stateData.data || {});
            prefillForm(stateData.data);
          } else {
            handleEmptyState();
          }

          if (settingsData.success) {
            updateSchedulerUI(
              settingsData.settings || {
                auto_run: false,
                interval: 60,
                next_run: null,
              }
            );
          }
        } catch (error) {
          console.error("Initialization error:", error);
          handleEmptyState();
          showToast(
            "Failed to initialize application. Using default state.",
            "warning"
          );
        } finally {
          hideLoadingState();
        }
      }

      function handleEmptyState() {
        // Show first-time user guidance
        updateLastRunStatus({
          state: "new",
          message: "Welcome! Enter your credentials to start scraping.",
          last_run: null,
          next_run: null,
        });

        // Reset all progress stages
        document.querySelectorAll(".stage").forEach((stage) => {
          stage.className = "stage";
          stage.querySelector("p").textContent = "Not started";
          stage.querySelector("small").textContent = "";
        });

        // Clear event log
        document.getElementById("eventLog").innerHTML = "";
      }

      function showLoadingState() {
        const loadingDiv = document.createElement("div");
        loadingDiv.id = "pageLoader";
        loadingDiv.className =
          "position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-white bg-opacity-75";
        loadingDiv.innerHTML = `
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    `;
        document.body.appendChild(loadingDiv);
      }

      function hideLoadingState() {
        const loader = document.getElementById("pageLoader");
        if (loader) {
          loader.remove();
        }
      }

      // Update the prefillForm function
      function prefillForm(data) {
        if (!data) return;

        const usernameField = document.getElementById("username");
        const passwordField = document.getElementById("password");
        const portalField = document.getElementById("portal");

        if (data.username && usernameField) {
          usernameField.value = data.username;
        }

        if (data.password && passwordField) {
          passwordField.value = data.password;
        }

        if (data.portal && portalField) {
          portalField.value = data.portal;
        }

        // Show appropriate UI based on state
        if (data.state === "running") {
          disableForm(true);
          showProgressTracker();
        } else {
          disableForm(false);
        }
      }

      function disableForm(disabled) {
        const form = document.getElementById("scraperForm");
        if (!form) return;

        const inputs = form.querySelectorAll("input, button");
        inputs.forEach((input) => {
          input.disabled = disabled;
        });
      }

      // Update socket event handlers for better error handling
      socket.on("connect_error", function (error) {
        console.error("Socket connection error:", error);
        showToast("Lost connection to server. Retrying...", "error");
      });

      socket.on("connect", function () {
        console.log("Socket connected");
        showToast("Connected to server", "success");
      });

      // Update error handling in startScraper
      async function startScraper(event) {
        event.preventDefault();
        const submitBtn = event.target.querySelector('button[type="submit"]');
        const form = event.target;

        try {
          submitBtn.disabled = true;
          form.classList.add("was-validated");

          if (!form.checkValidity()) {
            throw new Error("Please fill all required fields");
          }

          const formData = {
            username: document.getElementById("username").value,
            password: document.getElementById("password").value,
            portal: document.getElementById("portal").value,
          };

          resetUI();
          showProgressTracker();

          const response = await fetch(API_ENDPOINTS.START_SCRAPING, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(formData),
          });

          if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
          }

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.message || "Unknown error occurred");
          }

          updateStatus("Scraper started successfully", "info");
        } catch (error) {
          console.error("Scraper error:", error);
          showToast(error.message, "error");
          updateStatus(error.message, "error");
          handleEmptyState();
        } finally {
          submitBtn.disabled = false;
        }
      }

      // Update the DOMContentLoaded event listener
      document.addEventListener("DOMContentLoaded", function () {
        initializePage();

        // Add form validation listeners
        const forms = document.querySelectorAll(".needs-validation");
        forms.forEach((form) => {
          form.addEventListener("submit", (event) => {
            if (!form.checkValidity()) {
              event.preventDefault();
              event.stopPropagation();
            }
            form.classList.add("was-validated");
          });
        });
      });

      // Member management stage updates

      // Update progress handler to enforce stage progression
      socket.on("portal_scraper_progress", function (data) {
        if (!data || !data.stage) return;

        const stage = stageConfig[data.stage];
        if (!stage) return;

        // Validate stage progression
        if (stage.requires) {
          const missingStages = stage.requires.filter(
            (requiredStage) =>
              !document
                .getElementById(`${requiredStage}-stage`)
                ?.classList.contains("completed")
          );
          if (missingStages.length > 0) {
            console.error(
              `Stage ${data.stage} cannot start: ${missingStages.join(
                ", "
              )} must complete first`
            );
            return;
          }
        }

        // Update stage element
        const stageElement = document.getElementById(`${data.stage}-stage`);
        if (stageElement) {
          // Update status class
          stageElement.className = `stage ${data.status || ""}`;

          // Update step message
          const messageElement = stageElement.querySelector("p");
          if (messageElement) {
            messageElement.textContent =
              data.message || `${data.stage} in progress`;
          }

          // Show required label
          const labelElement = stageElement.querySelector(".stage-label");
          if (labelElement && stage.required) {
            labelElement.textContent = `${stage.name || data.stage} (Required)`;
          }

          // Add step to event log
          addEventLog({
            type: data.status === "error" ? "error" : "info",
            message: data.message,
            elapsed: data.timing,
          });

          // Enable next stage if this one completes
          if (data.status === "completed" && stage.next) {
            enableNextStage(stage.next);
          }
        }
      });

      function enableNextStage(stageName) {
        const nextStageElement = document.getElementById(`${stageName}-stage`);
        if (nextStageElement) {
          nextStageElement.classList.remove("disabled");
          nextStageElement
            .querySelector(".stage-label")
            ?.classList.remove("text-muted");
        }
      }

      // Update showProgressTracker to reflect mandatory sequence
      function showProgressTracker() {
        document.querySelectorAll(".stage").forEach((stage) => {
          const stageId = stage.id.replace("-stage", "");
          if (stageConfig[stageId]) {
            // All stages start disabled except initialization
            if (stageId !== "initialization") {
              stage.classList.add("disabled");
              stage.querySelector(".stage-label")?.classList.add("text-muted");
            }
            // Add required indicator
            const label = stage.querySelector(".stage-label");
            if (label && stageConfig[stageId].required) {
              label.textContent += " (Required)";
            }
          }
        });
        updateStageStatus("initialization", "starting", "Starting...");
      }

      socket.on("scheduler_update", function (data) {
        if (data.settings) {
          updateSchedulerUI(data.settings);
          updateNextRunDisplay(data.settings.next_run, data.settings.auto_run);
          showToast(
            `Scheduler ${
              data.settings.auto_run ? "enabled" : "disabled"
            }. Next run: ${formatTimestamp(data.settings.next_run)}`,
            "info"
          );
        }
      });

      function updateStatus(message, type = "info") {
        const statusElement = document.getElementById("scrapperStatus");
        if (!statusElement) return;
        
        const statusClasses = {
            'info': 'text-info',
            'error': 'text-danger',
            'success': 'text-success',
            'warning': 'text-warning'
        };
        
        statusElement.innerHTML = `
            <p class="${statusClasses[type] || 'text-info'}">${message}</p>
        `;
      }

      // Update socket event handlers
      socket.on("portal_scraper_event", function(data) {
          console.log("Event received:", data);
          if (!data) return;
          
          addEventLog({
              type: data.type || "info",
              message: data.message,
              stage: data.stage,
              step: data.step,
              timestamp: data.timestamp
          });
      });
    </script>
  </body>
</html>
